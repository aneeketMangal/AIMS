--Create a table of tickets for Dean Academics (and grant access only to dean)
--Write a trigger, whenever a new entry is made in batches table, a table of tickets is created for the batch advisor
--For the batch advisor ticket table, "GRANT --- ON --- TO <batch advisor>"
--i.e. Access should be granted only to batch advisor rather than to faculty
--Similarly, a table can be created/updated for each student whenever he/she raises a ticket (which shows status)
--Constraints to be checked can be that the course must be offered

--

-- ticket history
CREATE TABLE tickets(
    id SERIAL NOT NULL,
    student_id integer NOT NULL,
    course_id integer NOT NOT NULL,
    faculty_ap integer NOT NULL,
    advisor_ap integer NOT NULL, 
    dean_ap integer NOT NULL,
    PRIMARY KEY(id)
);

-- view student's ticket
CREATE OR REPLACE FUNCTION view_ticket_status(
    ticket_id int
)
RETURNS record
AS $_$
DECLARE
    create_table_command text;
    stu_id integer;
    out record;
BEGIN
    if NOT EXISTS(SELECT 1 from tickets t where t.id = ticket_id) then
        RAISE EXCEPTION 'Invalid ticket ID';
    END if;

    stu_id := CAST(substr(user, 2) AS INTEGER);
    if NOT EXISTS(SELECT 1 FROM tickets t WHERE t.id = ticket_id AND t.student_id = stu_id) then
        RAISE EXCEPTION 'Unauthorised action.';
    END if;

    SELECT course_id, faculty_ap, advisor_ap, dean_ap
    INTO out 
    FROM tickets
    WHERE tickets.id = tickets_id;
END
$_$
LANGUAGE plpgsql
SECURITY DEFINER;

GRANT EXECUTE
ON FUNCTION view_ticket_status
TO students;


--general ticket table template
CREATE OR REPLACE FUNCTION create_ticket_table(
    table_name text
)
RETURNS void
AS $_$
DECLARE
    create_table_command text;
BEGIN
    create_table_command := 'CREATE TABLE ' || table_name || ' (';

    create_table_command := create_table_command || ' id INTEGER NOT NULL,';
    create_table_command := create_table_command || ' student_id char(11) NOT NULL,';
    create_table_command := create_table_command || ' course_id INTEGER NOT NULL,';
    create_table_command := create_table_command || ' PRIMARY KEY(id),';
    create_table_command := create_table_command || ' FOREIGN KEY(id) REFERENCES tickets(id),';
    create_table_command := create_table_command || ' FOREIGN KEY(student_id) REFERENCES students(id),';
    create_table_command := create_table_command || ' FOREIGN KEY(course_id) REFERENCES course_offering(id));';
    EXECUTE create_table_command;
END
$_$
LANGUAGE plpgsql;

--creating dean_tickets_table;
SELECT create_ticket_table('dean_tickets');

GRANT ALL 
ON dean_tickets
TO deanoffice;


-- ticket raise by student
-- defined by superuser
CREATE OR REPLACE FUNCTION raise_ticket(
    offering_id integer
)
RETURNS void
AS $_$
DECLARE
    stu_id integer;
    table_name text;
    ins_id integer;
    insert_command text;
    ticket_id integer;
BEGIN
    stu_id := substr(user, 2);
    
    ins_id := (SELECT c.insid from course_offering c where c.id = $1);
    table_name := concat('_', ins_id,  '_instructor_tickets');

    if EXISTS(SELECT 1 FROM table_name t where t.student_id = stu_id AND t.course_id = $1) then
        RAISE EXCEPTION 'Ticket already raised';
        RETURN;
    END if;

    ticket_id := (SELECT COUNT(*)+1 from tickets);
    insert_command := 'INSERT INTO ' || table_name || ' VALUES(id, student_id, course_id) VALUES (' ||ticket_id || ',' || stu_id || ',' || $1 || ');' ;
    EXECUTE insert_command;
    insert_command := 'INSERT INTO tickets(student_id, course_id, faculty_ap, advisor_ap, dean_ap) VALUES (' || stu_id || ',' || $1 || ', 0, 0, 0)';
    EXECUTE insert_command;

END
$_$
LANGUAGE plpgsql
SECURITY DEFINER;

GRANT EXECUTE
ON PROCEDURE raise_ticket
TO students;


CREATE OR REPLACE FUNCTION propagate(
    ticket_id int, 
    table_from text, 
    table_to text
)
RETURNS void
AS $_$
DECLARE

BEGIN

    INSERT INTO table_to(id, student_id, course_id)
    SELECT tf.id, tf.student_id, tf.course_id
    FROM table_from tf WHERE tf.id = ticket_id;

    DELETE FROM table_from tf
    WHERE tf.id  = ticket_id;

END
$_$
LANGUAGE plpgsql
SECURITY DEFINER;





-- updation of status of raised ticket by instructor
CREATE OR REPLACE FUNCTION instructor_ticket_response(
    ticket_id integer,
    response boolean
)
RETURNS void
AS $_$
DECLARE
    table_name text;
    department text;
    adv_table_name text;
    ins_id integer;
    update_command text;
    delete_command text;
BEGIN
    ins_id := CAST(substr(user, 2) AS INTEGER);
    table_name := concat('_', ins_id,  '_instructor_tickets');

    if NOT EXISTS (SELECT 1 FROM tickets t where t.id = ticket_id) then
        RAISE EXCEPTION 'invalid ticket id';
        RETURN;
    END if;


    if NOT EXISTS (SELECT 1 FROM table_name t where t.id = ticket_id) then
        RAISE EXCEPTION 'Unauthorised Request.';
        RETURN;
    END if;

    if (response) then
        update_command := 'UPDATE tickets set tickets.faculty_ap = 2 WHERE tickets.id = ticket_id;';
        department := (
            SELECT st.batch
            FROM students st
            WHERE st.id = (SELECT ti.student_id from table_name ti where ti.id = ticket_id));
        adv_table_name := concat('_', department,  '_advisor_tickets');
        EXECUTE update_command;
        EXECUTE propagate(table_name, adv_table_name);
    else
        update_command := 'UPDATE tickets set tickets.faculty_ap = 1 WHERE tickets.id = ticket_id;';
        EXECUTE update_command;
    END if;
END
$_$
LANGUAGE plpgsql
SECURITY DEFINER;

GRANT EXECUTE
ON FUNCTION instructor_ticket_response
TO faculty;



-- advisor ticket response
CREATE OR REPLACE FUNCTION advisor_ticket_response(
    ticket_id integer,
    response boolean
)
RETURNS void
AS $_$
DECLARE
    table_name text;
    batch_ text;
    ins_id integer;
    update_command text;
    delete_command text;
BEGIN
    ins_id := CAST(substr(user, 2) AS INTEGER);
    if NOT EXISTS(SELECT 1 from batches b WHERE b.adv_id = ins_id) then
        RAISE EXCEPTION 'unauthorised access';
        RETURN;
    END if;

    batch_ := (SELECT b.batch from batches b WHERE b.adv_id = ins_id);
    table_name := concat('_', batch_,  '_advisor_tickets');

    if NOT EXISTS (SELECT 1 FROM tickets t where t.id = ticket_id) then
        RAISE EXCEPTION 'invalid ticket id';
        RETURN;
    END if;


    if NOT EXISTS (SELECT 1 FROM table_name t where t.id = ticket_id) then
        RAISE EXCEPTION 'ticket access unauthorised';
        RETURN;
    END if;

    if (response) then
        update_command := 'UPDATE tickets set tickets.advisor_ap = 2 WHERE tickets.id = ticket_id;';
        EXECUTE update_command;
        EXECUTE propagate(table_name, _dean_tickets);
    else
        update_command := 'UPDATE tickets set tickets.advisor_ap = 1 WHERE tickets.id = ticket_id;';
        EXECUTE update_command;
    END if;
    RETURN;
END
$_$
LANGUAGE plpgsql
SECURITY DEFINER;



CREATE TRIGGER advisor_ticket_table
AFTER INSERT
ON batches
FOR EACH ROW
EXECUTE PROCEDURE create_advisor_ticket_table();

CREATE OR REPLACE FUNCTION dean_ticket_response(
    ticket_id integer,
    response boolean
)
RETURNS void
AS $_$
DECLARE
    table_name text;
    batch_ text;
    update_command text;
BEGIN
    if (response) then
        update_command := 'UPDATE tickets set tickets.dean_ap = 2 WHERE tickets.id = ticket_id;';
    else
        update_command := 'UPDATE tickets set tickets.advisor_ap = 1 WHERE tickets.id = ticket_id;';
    END if;
    EXECUTE update_command;
    DELETE FROM dean_tickets WHERE dean_tickets.id = ticket_id;
    RETURN NULL;
END
$_$
LANGUAGE plpgsql;